import math
from dataclasses import dataclass


@dataclass
class Pf2eElement:
    name: str
    level: int = 0
    cost: float = 0.0
    rarity: int = 0


@dataclass
class EttPlayer:
    player_name: str
    name: str
    player_level: int
    time_played: float
    gained_karma: int

def ett_xp_rate(player_level, party_level):
    # GMs get 1.5x xp regardless. GM "Players" have a level of 0
    if player_level == 0:
        return 1.5

    # example: party level = 3, player level = 5. party - player = -2
    # 2 ** (-2 /2) = 2 ** -1 = 0.5
    # Example 2: party level = 3, player level = 2. party - player = 1
    # 2 ** (1/2) ~= 1.4
    # All of the XP calculations follow this format
    level_diff = party_level - player_level
    return 2 ** (level_diff / 2)


# Calculate the gold generated by adding xp given current xp.
def ett_gold_add_xp(current_xp, xp_to_add):
    xp_level = 12
    gold_rates = [3, 4, 7.5, 13, 20, 30, 45, 60, 90, 120, 170, 250, 375, 550, 800, 1250, 1900, 3100, 5300, 7400]
    cumulative_gold = 0
    while xp_to_add > 0:
        cur_level = math.floor(current_xp / 12)
        xp_to_next = 12 - (current_xp % 12)
        # If level 20, no extra levels can be gained so quit out now.
        if cur_level >= 19:
            cur_level = 19
            xp_to_next = xp_to_add

        # This xp would not level us up further, take whatever gold you had from older levels and add
        # the gold from this level.
        if xp_to_add <= xp_to_next:
            return gold_rates[cur_level] * xp_to_add + cumulative_gold

        cumulative_gold += gold_rates[cur_level] * xp_to_next
        # Level up our character so we can get the higher gold rates next time
        xp_to_add -= xp_to_next
        current_xp += xp_to_next


def ett_leveling_karma(current_xp, xp_to_add):
    # if you would become level 2 but are not currently level 2, you gain an extra 3 karma.
    if (current_xp + xp_to_add) >= 12 > current_xp:
        return 3
    return 0


def ett_party_level(players: list[EttPlayer]):
    power_levels = [0, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536]
    apl = 0
    non_gm_players = len(players) - 1
    for player in players:
        apl += power_levels[player.player_level]
    apl = apl / non_gm_players

    for p in range(1, len(power_levels)):
        # If true, then p is either one level too high, or our level
        if (apl - power_levels[p]) <= 0:
            lower = apl - power_levels[p - 1]
            higher = power_levels[p] - apl
            # if we are closer to the higher level than the lower power level
            if higher < lower:
                return p
            # otherwise we return the lower one. If higher = lower then we return lower
            # eg a party of 1 1 2 2 is a party level of 1 even tho it's perfectly in the middle
            return p - 1
    return 1


def pf2e_element_list_to_string(elements: list[Pf2eElement]):
    output_str = ''
    for element_index in range(len(elements)):
        i = elements[element_index]
        output_str += i.name + "|" + i.level + "|" + i.cost + "|" + i.rarity
        if element_index < (len(elements) - 1):
            output_str += "\n"
    return output_str


def string_to_pf2e_element_list(elements: str):
    e_str = elements.splitlines(False)
    element_list = []
    for line in e_str:
        attribs = line.split("|")
        element_list.append(Pf2eElement(attribs[0], int(attribs[1]), float(attribs[2]), int(attribs[3])))
    return element_list
