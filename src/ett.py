import math
from dataclasses import dataclass


@dataclass
class Pf2eElement:
    name: str
    level: int = 0
    cost: float = 0.0
    rarity: int = 0
    quantity: int = 1


@dataclass
class EttGamePlayer:
    player_name: str
    name: str
    player_level: int
    time_played: float
    gained_karma: int
    alive: bool


STARTING_GOLD = 15.0
XP_PER_LEVEL = 12
STARTING_SLOTS = 5
STARTING_KARMA = 1
NEW_FACE_BASE_COST = 5
NEW_FACE_COST_PER = 1
# for karma - name = name, level = cost (sorry),
# rarity = 0 -> instant consumable, 1 -> character, 2 -> player
KARMA_REWARDS = [Pf2eElement("Community Serviced", 1), Pf2eElement("Chosen Ally", 1), Pf2eElement("Upgrade Please", 2),
                 Pf2eElement("Extra Retrain", 2), Pf2eElement("Mini Rework", 1), Pf2eElement("Full Rework", 2),
                 Pf2eElement("Bulk Retrain", 1), Pf2eElement("Return Policy", 1),
                 Pf2eElement("Look What I Found", 4), Pf2eElement("Personal Staff", 5),
                 Pf2eElement("PS Uncommon Spell", 2), Pf2eElement("PS Rare Spell", 4),
                 Pf2eElement("Skeleton Key", level=6, rarity=1), Pf2eElement("No Interest Loan", 10),
                 Pf2eElement("True Time Traveler", level=50, rarity=2), Pf2eElement("New Big Friend", 50),
                 Pf2eElement("New Face", rarity=2),
                 Pf2eElement("Ultima Key", level=50, rarity=2)
                 ]


def get_new_face_karma_cost(new_face: Pf2eElement, upgrades: str):
    upgrades_elements = string_to_pf2e_element_list(upgrades)
    new_faces = 0
    for i in upgrades_elements:
        if i.name == "New Face":
            new_faces += i.quantity
            break
    # Karma to buy the first newface
    start_cost = NEW_FACE_BASE_COST + (new_faces * NEW_FACE_COST_PER)
    # Karma to buy the one after the last newface
    end_cost = start_cost + (new_face.quantity * NEW_FACE_COST_PER)
    return sum(range(start_cost, end_cost, NEW_FACE_COST_PER))


def get_available_slots(upgrades: str, characters: list):
    upgrades_elements = string_to_pf2e_element_list(upgrades)
    new_faces = 0
    for i in upgrades_elements:
        if i.name == "New Face":
            new_faces += i.quantity
            break
    return STARTING_SLOTS + new_faces - len(characters)


def get_level(xp):
    lv = 1 + math.floor(xp / XP_PER_LEVEL)
    if lv > 20:
        lv = 20
    return lv


def ett_xp_rate(player_level, party_level):
    # GMs get 1.5x xp regardless. GM "Players" have a level of 0
    if player_level == 0:
        return 1.5

    # example: party level = 3, player level = 5. party - player = -2
    # 2 ** (-2 /2) = 2 ** -1 = 0.5
    # Example 2: party level = 3, player level = 2. party - player = 1
    # 2 ** (1/2) ~= 1.4
    # All of the XP calculations follow this format
    print("party level and player level are ", party_level, player_level)
    level_diff = party_level - player_level
    return 2 ** (level_diff / 2)


# Calculate the gold generated by adding xp given current xp.
def ett_gold_add_xp(current_xp, xp_to_add):
    gold_rates = [3, 4, 7.5, 13, 20, 30, 45, 60, 90, 120, 170, 250, 375, 550, 800, 1250, 1900, 3100, 5300, 7400]
    cumulative_gold = 0

    # What if we are subtracting XP? Parse that here.
    if xp_to_add < 0:
        net_xp = current_xp + xp_to_add
        # if less than 0, let's just set it to 0 by calculating the gold at 0.
        if net_xp < 0:
            net_xp = 0
        return -ett_gold_add_xp(net_xp, current_xp)

    while xp_to_add > 0:
        cur_level = get_level(current_xp) - 1
        xp_to_next = XP_PER_LEVEL - (current_xp % XP_PER_LEVEL)
        # If level 20, no extra levels can be gained so quit out now.
        if cur_level >= 19:
            cur_level = 19
            xp_to_next = xp_to_add

        # This xp would not level us up further, take whatever gold you had from older levels and add
        # the gold from this level.
        if xp_to_add <= xp_to_next:
            return gold_rates[cur_level] * xp_to_add + cumulative_gold

        cumulative_gold += gold_rates[cur_level] * xp_to_next
        # Level up our character so we can get the higher gold rates next time
        xp_to_add -= xp_to_next
        current_xp += xp_to_next
    return 0


def ett_leveling_karma(current_xp, xp_to_add):
    # if you would become level 2 but are not currently level 2, you gain an extra 3 karma.
    if (current_xp + xp_to_add) >= XP_PER_LEVEL > current_xp:
        return 3
    # If you gain another level but are not currently that level you gain an extra 1 karma.
    cur_level = get_level(current_xp)
    new_level = get_level(current_xp + xp_to_add)
    if cur_level < new_level:
        return 1
    return 0


# Get hours of community service to revive character
def ett_died_cs(player: EttGamePlayer, true_level, ironman):
    default_rate = 1
    default_max = 8
    # If you are time traveling via karma rewards your level is considered to be the average of the level you played as
    # and the level your "true character" actually is (round down)
    ett_level = math.floor((player.player_level + true_level) / 2)
    if ironman == 1 or ironman == 2:
        return 9999
    if ironman == 3:
        return max(default_rate * ett_level, default_max)
    return min(default_max, default_rate * ett_level)


# This does three things. 1. it removes any NON RARE unlocks at or below the PC level
# 2. it appends any NEW unlocks to the list if applicable.
# 3. it removes any items from the remove_unlocks list
def ett_parse_unlocks(cur_unlocks: list[Pf2eElement], new: list[Pf2eElement], remove: list[Pf2eElement], pl_level):
    # Remove non rare unlocks at or below the PC level
    items = []
    for i in cur_unlocks:
        if i.rarity != 2 and i.level <= pl_level:
            continue
        items += [i]

    for i in new:
        # Do not add redundant items that do not need unlocking
        if i.rarity != 2 and i.level <= pl_level:
            continue
        exists = False
        for j in items:
            if j.name == i.name:
                exists = True
                break
        if not exists:
            items += [i]

    # Remove any items to remove with this disgustingly inefficient loop.
    items2 = []
    for j in items:
        keep_item = True
        for i in remove:
            if i.name == j.name:
                keep_item = False
        if keep_item:
            items2 += [j]
    return items2


def ett_party_level(players: list[EttGamePlayer]):
    power_levels = [0, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536]
    apl = 0
    non_gm_players = len(players) - 1
    for player in players:
        apl += power_levels[player.player_level]
    apl = apl / non_gm_players

    for p in range(1, len(power_levels)):
        # If true, then p is either one level too high, or our level
        if (apl - power_levels[p]) <= 0:
            lower = apl - power_levels[p - 1]
            higher = power_levels[p] - apl
            # if we are closer to the higher level than the lower power level
            if higher < lower:
                return p
            # otherwise we return the lower one. If higher = lower then we return lower
            # eg a party of 1 1 2 2 is a party level of 1 even tho it's perfectly in the middle
            return p - 1
    return 1


def pf2e_element_list_to_string(elements: list[Pf2eElement]):
    output_str = ''
    for element_index in range(len(elements)):
        i = elements[element_index]
        output_str += i.name + "|" + str(i.level) + "|" + str(i.cost) + "|" + str(i.rarity) + "|" + str(i.quantity)
        if element_index < (len(elements) - 1):
            output_str += "\n"
    return output_str


def string_to_pf2e_element_list(elements: str):
    if not elements:
        return []
    e_str = elements.splitlines(False)
    element_list = []
    for line in e_str:
        a = line.split("|")
        element_list.append(Pf2eElement(a[0], int(a[1]), float(a[2]), int(a[3]), int(a[4])))
    return element_list
